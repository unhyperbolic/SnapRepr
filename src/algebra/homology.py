import random
from matrix import *

def non_zero_column(m,j):
    zero=m.the_type.zero()
    for r in m.values:
        if not r[j]==zero:
            return True
    return False

def non_zero_row(m,j):
    zero=m.the_type.zero()
    for c in m.values[j]:
        if not c==zero:
            return True
    return False
    

def reduced_row_echelon_form(m,start_row=0):
    """
    returns (mA, A, inverse of A) such that
    mA is in reduced row echelon form
    """


    A=identity_matrix(m.no_rows(),m.the_type)
    Ainv=identity_matrix(m.no_rows(),m.the_type)
    m=matrix(m)
    
    current_row=start_row
    current_column=0

    while current_row < m.no_rows() and current_column < m.no_columns():
        
        if m.values[current_row][current_column]==0:
            for r in range(current_row+1, m.no_rows()):
                if not m.values[r][current_column]==0:
                    m.swap_rows(current_row, r)
                    A.swap_rows(current_row, r)
                    Ainv.swap_columns(r, current_row)
                    break
                
        if m.values[current_row][current_column] == 0:
            current_column += 1

        else:
            t = m.the_type.one() / m.values[current_row][current_column]
            m.multiply_row(current_row, t)
            A.multiply_row(current_row, t)
            Ainv.multiply_column(current_row, m.the_type.one() / t)
            
            for j in range(current_row+1, m.no_rows()):
                t = -m.values[j][current_column]
                m.add_to_row_p_times_row(j, t, current_row)
                A.add_to_row_p_times_row(j, t, current_row)
                Ainv.add_to_column_p_times_column(current_row, -t, j)

            current_column+=1
            current_row+=1

    assert A * Ainv == identity_matrix(m.no_rows(),m.the_type)

    return m, A, Ainv

def transpose_reduced_row_echelon_form(m, start_column=0):
    m, A, Ainv = reduced_row_echelon_form(m.transpose(), start_column)
    return m.transpose(),  A.transpose(),  Ainv.transpose()


def base_change_chain_complex(d2, d1): # such that d1 * d2 = 0
    """
    Consider the following chain complex over a field

              C_2  ------>  C_1  ------>  C_0
                     d_2           d_1

                        d_2 * d_1 = 0

    d_2 and d_1 are represented as matrices (acting by left multiplication
                                             on column vectors)

    By changing the basis of C_1 to base the matrices will take the form

         d_2:          1 ... x ... x ... x x x x
                       0 ... 1 ... x ... x x x x    there will be dim(im(d_2))
                       0 ... 0 ... 1 ... x x x x    rows starting with a 1 at
                                   ...              a different column each
                                   ...
                       0 ..................... 0    all other rows will be 0
                       0 ..................... 0

         d_1:          0 ... 0 1 x x ... x 0 ... 0
                       0 ... 0 0 x x ... x 0 ... 0
                       0 ... 0 0 1 x ... x 0 ... 0
                       0 ... 0 0 0 1 ... x 0 ... 0
                                  ...
                                  ...
                       0 ....................... 0

                 there will be | there will | there will be
                 dim(im(d_2))  | columns    | dim(ker(d_1))-dim(im(d_2))
                 columns of    | starting   | columns of zeros
                 zeros         | with a 1
                               | at a
                               | different
                               | row each

    In this basis, elements of ker(d_1) look like (x ... x 0 ... 0 x ... x)
               and elements of im(d_2)  look like (x ... x 0 ... 0 0 ... 0)

    Representatives of H_1 can be chosen to be    (0 ... 0 0 ... 0 x ... x).
    In the original basis, this means that the homology is generated by
    the last dim(ker(d_1))-dim(im(d_2)) column vectors of base.
    """

    # d1 * d2 == d1 * base_1_inv * base_1 * d2
    #
    #            \-------------/   \---------/    
    #                 d1_n1           d2_n1
    #
    #
    #                         base                  base_inv
    #                  /-----------------\   /----------------\
    #
    # d1 * d2 ==  d1 * base_1_inv * base_2 * inv_base2 * base_1 * d2
    #
    #             \----------------------/   \---------------------/
    #                      d1_n2                     d2_n2

    d2_n1, base_1, base_1_inv = reduced_row_echelon_form(d2)
    d1_n1 = d1 * base_1_inv

    dim_img_d2 = 0
    for r in range(d2_n1.no_rows()):
        if non_zero_row(d2_n1, r):
            dim_img_d2 += 1

    d1_n2, base_2, base_2_inv = transpose_reduced_row_echelon_form(d1_n1, dim_img_d2)
    d2_n2 = base_2_inv * d2_n1

    inv_base = base_2_inv * base_1
    base = base_1_inv * base_2

    assert d2_n1 == base_1 * d2
    assert d1 * d2 == d1_n1 * d2_n1
    assert d1_n2 == d1_n1 * base_2
    assert d1 * d2 == d1_n2 * d2_n2
    assert d2_n2 == inv_base * d2
    assert d1_n2 == d1 * base 

    return d2_n2, d1_n2, base, inv_base

def generate_pair_random_matrices(size,field):
    A=identity_matrix(size,field)
    Ainv=identity_matrix(size,field)


    assert A * Ainv == identity_matrix(size,field)


    for i2 in range(3*size):
        c1=random.randint(0,size-1)
        c2 = random.randint(0, size-1)
        if not c1 == c2:
            if random.randint(0, 1):
                A.swap_rows(c1, c2)
                Ainv.swap_columns(c2, c1)
            else:
                t1 = field.zero()
                for i in range(random.randint(0,20)):
                    t1 = t1 + field.one()
                t2 = field.zero()
                for i in range(random.randint(0,20)):
                    t2 = t2 + field.one()
                if (not t1 == field.zero()) and (not t2 == field.zero()):
                    t  = t1 / t2
                    A.add_to_row_p_times_row(c1, t, c2)
                    Ainv.add_to_column_p_times_column(c2, -t, c1)
        c1 = random.randint(0, size-1)
        t1 = field.zero()
        for i in range(random.randint(0,20)):
            t1 = t1 + field.one()
        t2 = field.zero()
        for i in range(random.randint(0,20)):
            t2 = t2 + field.one()
        if (not t1 == field.zero()) and (not t2 == field.zero()):
            t  = t1 / t2
            A.multiply_row(c1, t)
            Ainv.multiply_column(c1, field.one() / t)
    assert A * Ainv == identity_matrix(size,field)
    return A, Ainv

def generate_test_example_homology_generators(field,a,b,c,dim_im,dim_hom):
    dim_ker = dim_im + dim_hom
    assert dim_ker < b
    assert b < c
    assert dim_im < a
    assert dim_im < b

    d2 = matrix([[field.zero() for x in range(a)] for y in range(b)],field)
    d1 = matrix([[field.zero() for x in range(b)] for y in range(c)],field)

    for i in range(dim_im):
        d2.values[i][i] = field.one()
    for i in range(dim_ker,b):
        d1.values[i][i] = field.one()

    assert d1 * d2 == matrix([[field.zero() for x in range(a)] for y in range(c)],field)

    A, Ainv = generate_pair_random_matrices(a, field)
    B, Binv = generate_pair_random_matrices(b, field)
    C, Cinv = generate_pair_random_matrices(c, field)
    
    return B * d2 * A, C * d1 * Binv

def homology_generators(d2, d1, as_matrix_with_column_vectors = False):
    """
    As for base_change_chain_complex, consider the following chain complex over
    a field:

              C_2  ------>  C_1  ------>  C_0
                     d_2           d_1
                     
    homology_generators will return a list of a representatives in C_1 for
    each generator of H_1. If as_matrix_with_column_vectors is true, it will
    return a matrix where each column vector is a representative in C_1.

    >>> from fractions import Fraction
    >>> Fraction.one=staticmethod(lambda : Fraction(1,1))
    >>> Fraction.zero=staticmethod(lambda : Fraction(0,1))
    >>> d2 = matrix([[1,0,0,0,0,0],
    ...              [0,1,0,0,0,0],
    ...              [0,0,1,0,0,0],
    ...              [0,0,0,0,0,0],
    ...              [0,0,0,0,0,0]],
    ...              Fraction)
    >>> d1 = matrix([[0,0,0,0,0],
    ...              [0,0,0,0,0],
    ...              [0,0,0,0,0],
    ...              [0,0,0,0,0],
    ...              [0,0,0,0,1],
    ...              [0,0,0,0,0]],
    ...              Fraction)
    >>> homology_generators(d2,d1)
    [[Fraction(0, 1), Fraction(0, 1), Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)]]
    >>> d2, d1 = generate_test_example_homology_generators(Fraction,5,10,15,3,2)
    >>> H = homology_generators(d2, d1)
    >>> len(H)
    2
    >>> for h in H:
    ...     for i in d1 * h:
    ...         if not i == Fraction(0, 1):
    ...             raise Exception  
    """
    
    gens=[]
    
    n_d2, n_d1, base, base_inv = base_change_chain_complex(d2, d1)

    for i in range(n_d1.no_columns()):
        if (not non_zero_column(n_d1, i)) and (not non_zero_row(n_d2, i)):
            gens.append([r[i] for r in base.values])

    if as_matrix_with_column_vectors:
        return matrix(gens, d1.the_type).transpose()
    else:
        return gens

    
